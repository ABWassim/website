| Command | Description |
|:--------|:------------|
| check         | Verify all commit message against the conventional commit specification | 
| init          | Install cog config files                                                | 
| edit          | Rename all invalid commit message in the repo (interactive rebase)      | 
| log           | Like git log but for conventional commits                               | 
| verify        | Verify a single commit message                                          | 
| changelog     | Display a changelog for a given commit oid range                        | 
| bump          | Commit changelog from latest tag to HEAD and create a new tag           | 
| install-hook  | Add conventional git hooks to the repository                            |


## Repository initialization

⚠️ If you don't care about automatic versioning and just want to use `coco` to create conventional commits
you can skip this section and jump to the next one.

To get the most out of cocogitto you need to have a `cog.toml` config at the root of your repository.
You can create this file manually or generate the default one with `cog init`.

The default config file generated by cog init looks like this.
You can read the configuration reference for more information.


```toml
changelog_path = "CHANGELOG.md"
pre_bump_hooks = []
post_bump_hooks = []
authors = []

[commit_types]
```

## Creating a new repository

```bash
mkdir my_repo && cd my_repo
cog init
```

`cog init` works like `git init` except it create a template `cog.toml` config file,
and a default initial commit with the following message : `chore: initial commit`.

Optionally you can specify the target path of the repository you want to create :

```bash
cog init my_repo
```

## Initializing an existing repo

Running `cog init` on an existing repository will just create a template configuration without creating any commit :

```bash
git init my_repo && cd my_repo
cog init
```

```
❯ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	new file:   cog.toml
```

# Managing commit history

`cog` as several subcommands to examine and manipulate your commit history.

## Validate repository history compliance with the specification

Running `cog check` will check your commit history against the conventional commit specification :

```
❯ cog check
No errored commits
```

Let us create an invalid commit :
```sh
git commit -m "Your Mother Was A Hamster, And Your Father Smelt Of Elderberries"
```

And check our commit history again :
```
❯ cog check
Error: ERROR - Your Mother Was A Hamster, And Your Father Smelt Of Elderberries - (c2bb56)
	cause: Missing commit type separator `:
```

Additionally, you can check your history, starting from the latest tag to HEAD using `from-latest-tag` flag.  
This is useful when your git repo started to use conventional commits from a certain point in history, and you
don't care about editing old commits.

## Rewrite non-compliant commits

Once you have spotted invalid commits you can quickly fix your commit history by running `cog edit`.
This will perform an automatic rebase and let you edit each malformed commit message with your `$EDITOR`
of choice.

**Example :**

`cog edit` will cycle to each malformed commit to rewrite their message :

```
# Editing commit c2bb56b93821ff34282f322be4d2231f53b9ada8
# Replace this message with a conventional commit compliant one
# Save and exit to edit the next errored commit
Your Mother Was A Hamster, And Your Father Smelt Of Elderberries
```

::: danger
Using `cog edit` will modify your commit history and change the commit SHA of edited commit
and their child.
:::

## Conventional commits git log


`cog log` is like `git log` but it displays additional conventional commit information, such as commit scope,
commit type etc.


[![asciicast](https://asciinema.org/a/ssH4yRSlc28Rb9dHEDN7TowGe.svg)](https://asciinema.org/a/ssH4yRSlc28Rb9dHEDN7TowGe)

You can also filter the log content with the following flags (`cog log --help`) :

- `-B` : display breaking changes only
- `-t` : filter on commit type
- `-a` : filter on commit author
- `-s` : filter on commit scope
- `-e` : ignore errors

Those flag can be combined to achieve complex search in your commit history :

```sh
cog log --author "Paul Delafosse" "Mike Lubinets" --type feat --scope cli --no-error
```

### Changelog summary

There are two ways to generate changelog with `cog` :

- To your repo `CHANGELOG.md` file with `cog bump` (see: [auto bump](src/coco_guide/versioning.mdde/versioning.md#auto-bump))
- To stdout with `cog changelog`.

    ```markdown
    ❯ cog changelog
    
    ## 0.30.0..HEAD - 2020-09-30
    
    
    ### Bug Fixes
    
    7f04a9 - fix ci cross build command bin args - Paul Delafosse
    
    ### Features
    
    fc7420 - move check edit to dedicated subcommand and fix rebase - Paul Delafosse
    1028d0 - remove config commit on init existing repo - Paul Delafosse
    
    ### Refactoring
    
    d4aa61 - change config name to cog.toml - Paul Delafosse
    ```

::: tip
You can specify a custom changelog range or tag like so :
```
# Display the changelog between `^1` and `2.0.0`
cog changelog --at 2.0.0

# Display the changelog between `8806a5` and `HEAD`
# Note that shortened git oid are not supported yet for this command
cog changelog 8806a55..

# Display the changelog between `8806a5` and `1.0.0`
cog changelog 8806a5..1.0.0
```
:::


# Automatic versioning

The purpose of conventional commits is to be able to bump your project version and changelog
automatically. Cocogitto allow you to do this with the `cog bump` command.

The `bump` subcommand will execute the following steps :

1. Calculate the next version based on the commit types since the latest tag.
2. Append the changes for this version to `CHANGELOG.md`.
3. Execute a set configuration defined pre-bump hooks.
4. Create a version commit containing changes made during the previous steps.
5. Create a git tag on the version commit.
6. Execute a set of configuration defined post-bump hook.

### Auto bump

Assuming we are working on the following git repository :
```
* (HEAD -> master) feat: another cool feature
* docs: add some documentation
* fix: fix ugly bug
* feat: add awesome feature
* chore: initial commit
```

Let us now create a version :
```
❯ cog bump --auto
Found feature commit caef0f, bumping to 0.1.0
Skipping irrelevant commit 025cc0 with type : docs
Found bug fix commit e2af66, bumping to 0.1.1
Found feature commit 1b87aa, bumping to 0.2.0
Bumped version : 0.0.0 -> 0.2.0
```

If we look again at our git log :
```
(HEAD -> master, tag: 0.2.0) chore(version): 0.2.0
... 
```

Also, a `CHANGELOG.md` file have been created.

```markdown
# Changelog
All notable changes to this project will be documented in this file.
See [conventional commits](https://www.conventionalcommits.org/) for commit guidelines.

- - -
## 0.2.0 - 2020-09-30


### Bug Fixes

e2af66 - fix ugly bug - Paul Delafosse


### Documentation

025cc0 - add some documentation - Paul Delafosse


### Features

caef0f - another cool feature - Paul Delafosse

1b87aa - add awesome feature - Paul Delafosse


- - -

This changelog was generated by [cocogitto](https://github.com/oknozor/cocogitto).
```

You need to run `cog bump` with one of the following flags :
- `--auto` : choose the next version for you (based on feature commit, bug fixes commit and BREAKING_CHANGE commit).
- `--major` : increment the MAJOR version.
- `--minor` : increment the MINOR version.
- `--patch` : increment the PATCH version.
- `--version <version>` : set version manually (ex : `cog bump --version 3.2.1`).

You can also create pre-release version by adding the `--pre` flag to the bump command :

```shell script
cog bump --major --pre "beta.1"
```

Coming from `1.2.3` this would create the following tag : `2.0.0-beta.0`.


If you create a new version, the version changelog will be prepended to your changelog file separated by `- - -`.
Note that if your project already contains a changelog you can tell `cog` about it by adding this to the file :

```markdown
- - -
- - -
```

You might also need to adjust `changelog_path` in `cog.toml`.

**Note:** `cog bump --auto` treats `0.y.z` versions specially,
i.e. it will never do an auto bump to the `1.0.0` version, even if there are breaking changes.
That way, you can keep adding features in the development stage and decide yourself, when your API is stable.

## Bump hooks

### Pre bump hooks

Creating git tag automatically is great but sometimes you need to edit some file with the new version number,
or perform some additional checks before doing so.

A typical example is editing your project manifest in your package manager configuration file.
You can run pre bump commands with the `{{version}}` alias to reference the newly created version :

```toml
# cog.toml
pre_bump_hooks = [
    "cargo build --release",
    "cargo bump {{version}}",
]
```

When running `cog bump` these command will be run before creating the version commit.
Assuming we are bumping to `1.1.0`, the `{{version}}` alias will be replaced with `1.1.0`.

### Post bump hooks

You can tell `cog` to run commands after the bump.

```toml
# cog.toml
post_bump_hooks = [
    "git push",
    "git push origin {{version}}",
    "cargo publish"
]
```  

### Version DSL

It is common to bump your development branch version package manifest after creating a new release.
A typical example in the java world would be to bump your maven snapshot on your development branch after a release.

```toml
# cog.toml
post_bump_hooks = [
    "git push",
    "git push origin {{version}}",
    "git checkout develop",
    "git rebase master",
    "mvn versions:set -DnewVersion={{version+minor-SNAPSHOT}}",
    "coco chore \"bump snapshot to {{version+1minor-SNAPSHOT}}\"",
    "git push",
]
```

As you can see we are bumping the manifest using a small DSL. It as only a few keywords :
- start with the `version` keyword.
- followed by the `+` operator.
- `major`, `minor` and `patch` to specify the kind of increment you want.
  Then an optional amount, default being one (`version+1minor` and `version+minor` being the same).
- followed by any number of `+{amount}{kind}` (exemple: `version+2major+1patch`)
- ended by any alphanumeric character (SemVer additional labels for pre-release and build metadata), here `-SNAPSHOT`.

### Builtin git hooks

To protect your commit history, and your git remote, cog have builtins
[git hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks).

You can install them all by running :

```sh
cog install-hook all
```

Or one by one, specifying the hook name :

1. Pre-push hook

   Enabling this hook will run `cog check` before pushing to remote.
    ```
    cog install-hooks pre-push
    ```

2. Pre-commit hook

   Enabling this hook will run `cog verify` before creating a new commit.

    ```
    cog install-hook pre-commit
    ```
